# Created by Terraform Bootstrap

name: Redeploy latest image to ECS

on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    if: github.ref == 'refs/heads/dev' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/stage' 

    permissions:
      id-token: write
      contents: read

    outputs:
      lb_dns: ${{ steps.get-lb.outputs.lb_dns }}

    steps:
      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::858431073792:role/gh-actions-role
          aws-region: eu-central-1

      - name: Fetch ECS config
        run: |
          if [ "${GITHUB_REF}" = "refs/heads/dev" ]; then
            aws ssm get-parameter --name "/cd/dev/config" \
              --with-decryption --query "Parameter.Value" --output text > ecs.json
          fi
          if [ "${GITHUB_REF}" = "refs/heads/master" ]; then
            aws ssm get-parameter --name "/cd/prod/config" \
              --with-decryption --query "Parameter.Value" --output text > ecs.json
          fi
          if [ "${GITHUB_REF}" = "refs/heads/stage" ]; then
            aws ssm get-parameter --name "/cd/stage/config" \
              --with-decryption --query "Parameter.Value" --output text > ecs.json
          fi

          CLUSTER=$(jq -r '.cluster' ecs.json)
          SERVICE=$(jq -r '.service' ecs.json)
          
          echo "CLUSTER=$CLUSTER" >> $GITHUB_ENV
          echo "SERVICE=$SERVICE" >> $GITHUB_ENV

      - name: Force new ECS config
        run: |
          aws ecs update-service \
            --cluster "$CLUSTER" \
            --service "$SERVICE" \
            --force-new-deployment

      - name: Wait for ECS service
        run: |
          aws ecs wait services-stable \
            --cluster $CLUSTER \
            --services $SERVICE

      - name: Get ALB DNS name
        id: get-lb
        run: |
          TG_ARN=$(aws ecs describe-services \
            --cluster $CLUSTER \
            --services $SERVICE \
            --query "services[0].loadBalancers[0].targetGroupArn" \
            --output text)

          # Get the Load Balancer ARN from Target Group
          LB_ARN=$(aws elbv2 describe-target-groups \
            --target-group-arns $TG_ARN \
            --query "TargetGroups[0].LoadBalancerArns[0]" \
            --output text)

          # Get DNS name
          LB_DNS=$(aws elbv2 describe-load-balancers \
            --load-balancer-arns $LB_ARN \
            --query "LoadBalancers[0].DNSName" \
            --output text)

          echo "lb_dns=$LB_DNS" >> $GITHUB_OUTPUT

  smoketest:    
    runs-on: ubuntu-latest
    needs: deploy
    if: github.ref == 'refs/heads/dev' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/stage' 

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::858431073792:role/gh-actions-role
          aws-region: eu-central-1

      - name: Run smoke test
        env:
          LB_DNS: ${{ needs.deploy.outputs.lb_dns }}
        run: |
          echo "Running smoke test on $LB_DNS"
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://$LB_DNS/healthcheck)
          if [ "$STATUS" -ne 200 ]; then
            echo "Smoke test failed: HTTP $STATUS"
            exit 1
          fi
          echo "Smoke test passed: HTTP $STATUS"