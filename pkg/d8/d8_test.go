package d8

import (
	"advent2024/pkg/solver"
	"context"
	"errors"
	"strings"
	"testing"
	"time"
)

var (
	inputTest = `............
........0...
.....0......
.......0....
....0.......
......A.....
............
............
........A...
.........A..
............
............`
)

func TestValid(t *testing.T) {
	cases := []struct {
		name, input string
		part        int
		want        string
	}{
		{"test input part 1", inputTest, 1, "14"},
		{"test input part 2", inputTest, 2, "34"},
		{"test input part 21", inputTest, 21, "34"},
	}

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			puzzle := NewSolver()
			_ = puzzle.Init(strings.NewReader(c.input))
			got, _ := puzzle.Solve(c.part)

			if got != c.want {
				t.Errorf("part %d: got %s expected %s", c.part, got, c.want)
			}
		})
	}
}

func TestUnknownPart(t *testing.T) {
	invalidPart := 3

	want := solver.ErrUnknownPart

	puzzle := NewSolver()
	_ = puzzle.Init(strings.NewReader(inputTest))
	_, got := puzzle.Solve(invalidPart)

	if !errors.Is(got, want) {
		t.Errorf("Got %v expected %v", got, want)
	}
}

func TestInvalidInput(t *testing.T) {

	cases := []struct {
		name  string
		input string
	}{
		{"empty input", ``},
		{"unequal rows", "Invalid\nInput"},
	}

	want := solver.ErrInvalidInput

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			puzzle := NewSolver()
			got := puzzle.Init(strings.NewReader(c.input))

			if !errors.Is(got, want) {
				t.Errorf("Got %v expected %v", got, want)
			}
		})
	}
}

func TestAntinodes(t *testing.T) {
	tests := []struct {
		thisx, thisy   int
		otherx, othery int
		a1x, a1y       int
		a2x, a2y       int
	}{
		{1, 1, 3, 2, -1, 0, 5, 3},
	}

	for _, tt := range tests {
		this := Coords{x: tt.thisx, y: tt.thisy}
		other := Coords{x: tt.otherx, y: tt.othery}

		want1 := Coords{x: tt.a1x, y: tt.a1y}
		want2 := Coords{x: tt.a2x, y: tt.a2y}

		as := FindAntinodes(this, other)

		got1 := as[0]
		got2 := as[1]

		if !Eq(want1, got1) || !Eq(want2, got2) {
			t.Errorf("Got %v %v expected %v %v", got1, got2, want1, want2)
		}
	}
}

func BenchmarkPart2(b *testing.B) {
	input := `............s...............1.....................
......................E......3.....S..............
.......................3.....S....................
...e........T.t.......S.1...........I.............
..................B..................I.....O......
g.......z........i39......B..I....................
.......s....S.......3......................i..I...
....e.............2..........B....................
.......tC...z.......g......1......................
.E......s....R....................................
..G...t..........2................................
.........K...C.......2............................
....T..e...........5...C..........................
...T................................O...o.........
...............................g..............o...
.........z...................g......i............o
...9.E............H...........Y.......O...........
..........R..H...............7.O..................
...........H.............v......7........B........
..9.Q.......................W......1........Y.....
.........................z.7.................Y....
.....Q................................v...........
....K.......E.....R...............2..........o....
.n............H......v...........................Y
.G.y..........................Q...................
......G....A5.....................h...............
..........D...5.w...9.............................
......n....5...L..................................
............................v.....................
............L...0t..........7.....................
..n....k............y....................W........
..k..........0.........................W..........
...n.......R..L..a........................W.......
.........................................h........
..0..L........c...b...............................
.....................8.y..........................
.......w.................6.............h.......N..
..........y..4....................................
...0....8...k.....Z........r......................
..............a...8Z.........G......4.............
........4..b.q.....................K..............
.q...........kZ.K......b..D.........d.............
.8.....................D................r.........
.....w.........a...............d........A.........
................................d.A.hV............
................c..........D.....V....r...........
.......Z......6.....l........................A.d..
...................l..6..c....b......r...........N
......a....4........q..l..V..c................N...
l.....w...........q..6............V...............`

	puzzle := NewSolver()
	_ = puzzle.Init(strings.NewReader(input))

	b.ReportAllocs()

	for i := 0; i < b.N; i++ {
		_, _ = puzzle.Solve(2)
	}
}

func BenchmarkGoRoutines(b *testing.B) {
	input := `............s...............1.....................
......................E......3.....S..............
.......................3.....S....................
...e........T.t.......S.1...........I.............
..................B..................I.....O......
g.......z........i39......B..I....................
.......s....S.......3......................i..I...
....e.............2..........B....................
.......tC...z.......g......1......................
.E......s....R....................................
..G...t..........2................................
.........K...C.......2............................
....T..e...........5...C..........................
...T................................O...o.........
...............................g..............o...
.........z...................g......i............o
...9.E............H...........Y.......O...........
..........R..H...............7.O..................
...........H.............v......7........B........
..9.Q.......................W......1........Y.....
.........................z.7.................Y....
.....Q................................v...........
....K.......E.....R...............2..........o....
.n............H......v...........................Y
.G.y..........................Q...................
......G....A5.....................h...............
..........D...5.w...9.............................
......n....5...L..................................
............................v.....................
............L...0t..........7.....................
..n....k............y....................W........
..k..........0.........................W..........
...n.......R..L..a........................W.......
.........................................h........
..0..L........c...b...............................
.....................8.y..........................
.......w.................6.............h.......N..
..........y..4....................................
...0....8...k.....Z........r......................
..............a...8Z.........G......4.............
........4..b.q.....................K..............
.q...........kZ.K......b..D.........d.............
.8.....................D................r.........
.....w.........a...............d........A.........
................................d.A.hV............
................c..........D.....V....r...........
.......Z......6.....l........................A.d..
...................l..6..c....b......r...........N
......a....4........q..l..V..c................N...
l.....w...........q..6............V...............`

	b.ReportAllocs()

	puzzle := NewSolver()
	_ = puzzle.Init(strings.NewReader(input))

	for i := 0; i < b.N; i++ {
		_, _ = puzzle.Solve(21)
	}
}

func TestValidWithCtx(t *testing.T) {
	cases := []struct {
		name, input string
		part        int
		want        string
	}{
		{"test input part 1", inputTest, 1, "14"},
		{"test input part 2", inputTest, 2, "34"},
	}

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			puzzle := NewSolverWithCtx()
			_ = puzzle.InitCtx(context.Background(), strings.NewReader(c.input))
			got, _ := puzzle.SolveCtx(context.Background(), c.part)

			if got != c.want {
				t.Errorf("part %d: got %s expected %s", c.part, got, c.want)
			}
		})
	}
}

func TestCtxTimeout(t *testing.T) {
	cases := []struct {
		name, input string
		part        int
	}{
		{"test input part 1", inputTest, 1},
		{"test input part 2", inputTest, 2},
	}

	want := solver.ErrTimeout

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			puzzle := NewSolverWithCtx()
			_ = puzzle.InitCtx(context.Background(), strings.NewReader(c.input))

			ctx, cancel := context.WithTimeout(context.Background(), 250 * time.Millisecond)
			defer cancel()

			time.Sleep(500 * time.Millisecond)

			_, got := puzzle.SolveCtx(ctx, c.part)

			if got != want {
				t.Errorf("Got %v expected %v", got, want)
			}
		})
	}
}
