package d8

import (
	"strings"
	"testing"
)

func TestPart1(t *testing.T) {
	input := `............
........0...
.....0......
.......0....
....0.......
......A.....
............
............
........A...
.........A..
............
............`

	want := "14"

	puzzle := NewSolver()
	_ = puzzle.Init(strings.NewReader(input))
	got, _ := puzzle.Solve(1)

	if got != want {
		t.Errorf("Got %s expected %s", got, want)
	}
}

func TestPart2(t *testing.T) {
	input := `............
........0...
.....0......
.......0....
....0.......
......A.....
............
............
........A...
.........A..
............
............`

	want := "34"

	puzzle := NewSolver()
	_ = puzzle.Init(strings.NewReader(input))
	got, _ := puzzle.Solve(2)

	if got != want {
		t.Errorf("Got %s expected %s", got, want)
	}
}

func TestAntinodes(t *testing.T) {
	tests := []struct {
		thisx, thisy   int
		otherx, othery int
		a1x, a1y       int
		a2x, a2y       int
	}{
		{1, 1, 3, 2, -1, 0, 5, 3},
	}

	for _, tt := range tests {
		this := Coords{x: tt.thisx, y: tt.thisy}
		other := Coords{x: tt.otherx, y: tt.othery}

		want1 := Coords{x: tt.a1x, y: tt.a1y}
		want2 := Coords{x: tt.a2x, y: tt.a2y}

		as := FindAntinodes(this, other)

		got1 := as[0]
		got2 := as[1]

		if !Eq(want1, got1) || !Eq(want2, got2) {
			t.Errorf("Got %v %v expected %v %v", got1, got2, want1, want2)
		}
	}
}

func BenchmarkPart2(b *testing.B) {
	input := `............s...............1.....................
......................E......3.....S..............
.......................3.....S....................
...e........T.t.......S.1...........I.............
..................B..................I.....O......
g.......z........i39......B..I....................
.......s....S.......3......................i..I...
....e.............2..........B....................
.......tC...z.......g......1......................
.E......s....R....................................
..G...t..........2................................
.........K...C.......2............................
....T..e...........5...C..........................
...T................................O...o.........
...............................g..............o...
.........z...................g......i............o
...9.E............H...........Y.......O...........
..........R..H...............7.O..................
...........H.............v......7........B........
..9.Q.......................W......1........Y.....
.........................z.7.................Y....
.....Q................................v...........
....K.......E.....R...............2..........o....
.n............H......v...........................Y
.G.y..........................Q...................
......G....A5.....................h...............
..........D...5.w...9.............................
......n....5...L..................................
............................v.....................
............L...0t..........7.....................
..n....k............y....................W........
..k..........0.........................W..........
...n.......R..L..a........................W.......
.........................................h........
..0..L........c...b...............................
.....................8.y..........................
.......w.................6.............h.......N..
..........y..4....................................
...0....8...k.....Z........r......................
..............a...8Z.........G......4.............
........4..b.q.....................K..............
.q...........kZ.K......b..D.........d.............
.8.....................D................r.........
.....w.........a...............d........A.........
................................d.A.hV............
................c..........D.....V....r...........
.......Z......6.....l........................A.d..
...................l..6..c....b......r...........N
......a....4........q..l..V..c................N...
l.....w...........q..6............V...............`

	puzzle := NewSolver()
	_ = puzzle.Init(strings.NewReader(input))

	b.ReportAllocs()

	for i := 0; i < b.N; i++ {
		puzzle.Solve(2)
	}
}

func BenchmarkGoRoutines(b *testing.B) {
	input := `............s...............1.....................
......................E......3.....S..............
.......................3.....S....................
...e........T.t.......S.1...........I.............
..................B..................I.....O......
g.......z........i39......B..I....................
.......s....S.......3......................i..I...
....e.............2..........B....................
.......tC...z.......g......1......................
.E......s....R....................................
..G...t..........2................................
.........K...C.......2............................
....T..e...........5...C..........................
...T................................O...o.........
...............................g..............o...
.........z...................g......i............o
...9.E............H...........Y.......O...........
..........R..H...............7.O..................
...........H.............v......7........B........
..9.Q.......................W......1........Y.....
.........................z.7.................Y....
.....Q................................v...........
....K.......E.....R...............2..........o....
.n............H......v...........................Y
.G.y..........................Q...................
......G....A5.....................h...............
..........D...5.w...9.............................
......n....5...L..................................
............................v.....................
............L...0t..........7.....................
..n....k............y....................W........
..k..........0.........................W..........
...n.......R..L..a........................W.......
.........................................h........
..0..L........c...b...............................
.....................8.y..........................
.......w.................6.............h.......N..
..........y..4....................................
...0....8...k.....Z........r......................
..............a...8Z.........G......4.............
........4..b.q.....................K..............
.q...........kZ.K......b..D.........d.............
.8.....................D................r.........
.....w.........a...............d........A.........
................................d.A.hV............
................c..........D.....V....r...........
.......Z......6.....l........................A.d..
...................l..6..c....b......r...........N
......a....4........q..l..V..c................N...
l.....w...........q..6............V...............`

	b.ReportAllocs()

	puzzle := NewSolver()
	_ = puzzle.Init(strings.NewReader(input))

	for i := 0; i < b.N; i++ {
		puzzle.Solve(21)
	}
}
